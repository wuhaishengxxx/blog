---
layout: post
title:  "H5游戏开发之新手引导"
date:   2017-11-11 14:06:05
categories: H5
tags: H5 Egret 游戏 页游 JavaScript TypeScript
---

* content
{:toc}

本文主讲新手引导的程序设计思路，并不涉及到整个新手引导系统的设计。  

<!--more-->



## 前言
  新手引导的作用，是引导玩家快速的融入游戏当中。本人认为，在游戏设计中，新手引导应该简洁，不需要为不告诉玩家也会知道的操作去引导，比如创角。需要的是一下需要告诉玩家玩家才知道的操作，比如战斗，比如任务触发，还有一些核心的特色的地方。当然，新手引导的设计还是需要斟酌。

## 需求整理
- 触发类型：     新手引导一般有两种类型：1.按钮点击类型 ，2.只有对话类型
- 引导类型：   1.强指引 2. 弱指引


##界面设计
引导界面一般有以下几个需求： 1.全屏 2.层级最高 3.能监听点击到指定区域
先上效果图： 
![效果](http://www.whsblog.cn/images/guide/guide2.gif)  
![效果](http://www.whsblog.cn/images/guide/guide.gif)
皮肤：
```
<?xml version="1.0" encoding="utf-8"?>
<e:Skin class="guide.GuideSkin" width="1280" height="760" xmlns:e="http://ns.egret.com/eui"
        xmlns:w="http://ns.egret.com/wing">
	<e:Group id="dialogGrp" y="0" maxWidth="220" x="630" touchEnabled="false">
		<e:Image x="0" y="0" width="100%" height="100%" source="chatBg" scale9Grid="47,22,8,5"/>
		<e:Label id="dialogText" text="" size="22" bold="true" maxChars="10" multiline="true" textAlign="left" verticalAlign="top" bottom="20" left="10" top="10" right="10" maxWidth="180" textColor="0xfbebd7"/>
	</e:Group>
	<e:Image id="npcImg" source=""  scaleX="0.5" scaleY="0.5" x="10" y="36" touchEnabled="false"/>
	<e:Image id="guideRect" x="967" y="377" touchEnabled="true"
	          source="height_light_2" scale9Grid="10,9,2,4" pixelHitTest="true"/>
	<e:Group id="arrowsGrp" minHeight="50" minWidth="150" x="811" y="257" touchEnabled="false">
		<e:Image x="0" width="100%" y="0" height="100%"  source="arrow_12" scale9Grid="9,25,3,2"/>
		<e:Label id="touchTip" text="点击这里" size="18" textAlign="center" verticalAlign="middle"
		             right="10" left="10" bottom="10" top="10" textColor="0xfbebd7"/>
	</e:Group>
</e:Skin>
```
代码：

```
enum Side {
	Left = 0,
	Right = 1,
	Top = 2,
	Bottom = 3
}

/**
 * 引导配置的数据，使用表格生成的JSON数据，这里只是方便展示，实际并不放在这里
 */
let data =
	{
		"1": { "id": 1, "desc": "btn0", "type": 2, "dialog": "引导对话", "npcPos": [110, 100], "guideRect": [420, 150, 120, 52], "side": 0, "sideText": "点这里" },
		"2": { "id": 2, "desc": "btn1", "type": 2, "dialog": "引导对话", "npcPos": [110, 100], "guideRect": [420, 252, 120, 52], "side": 1, "sideText": "点这里" },
		"3": { "id": 3, "desc": "btn2", "type": 2, "dialog": "引导对话", "npcPos": [110, 100], "guideRect": [420, 354, 120, 52], "side": 2, "sideText": "点这里" },
		"4": { "id": 4, "desc": "btn3", "type": 2, "dialog": "引导对话", "npcPos": [110, 100], "guideRect": [420, 456, 120, 52], "side": 3, "sideText": "点这里" },
		"5": { "id": 5, "desc": "btn4", "type": 2, "dialog": "引导对话", "npcPos": [110, 100], "guideRect": [420, 558, 120, 52], "side": 0, "sideText": "点这里" }
	}


/**
 * 引导面板
 * 实际只负责展示面板内容，在实际开发中都是通过GuideManager来控制引导
 * 通过Mediator(中介器)来控制UI展示，处理事件
 */
class GuidePanel extends eui.Component {


	public dialogGrp: eui.Group;
	public dialogText: eui.Label;
	public npcImg: eui.Image;
	public arrowsGrp: eui.Group;
	public guideRect: eui.Image;
	// 箭头文本
	public touchTip: eui.Label;

	//箭头与边框的距离 
	public panding: number = 30;
	// 动画周期的一半 ms
	public effectTime: number = 500;
	public touchRect: egret.Rectangle;
	// 测试
	public static self: GuidePanel;
	// 步数
	private step: number;

	public constructor() {
		super();
		this.skinName = GuideSkin;
		GuidePanel.self = this;
		this.once(egret.Event.ADDED_TO_STAGE, this.initGuideEvent, this);

	}

	/**
	 * 给stage添加事件监听
	 * 这样设计并不好，会导致不停地出发，
	 * 原本设计点击框触发，但是无法穿透整个图片，按钮无法响应
	 */
	private initGuideEvent() {
		let stage = this.stage;
		if (stage) {
			if (!stage.hasEventListener(egret.TouchEvent.TOUCH_TAP)) {
				stage.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onGuideTouch, this);
			}
		}
	}

	/**
	 * 点击处理
	 */
	private onGuideTouch(event: egret.TouchEvent) {

		/**
		 * 对点击事件进行处理，点到点击区域再触发
		 */
		if (this.touchRect && this.touchRect.contains(event.stageX, event.stageY)) {
			let step = this.step ? this.step + 1 : 1;
			if (data[step]) {
				this.showGuide(step);
			} else {
				this.destory();
			}
		}
	}


	public showGuide(step) {
		this.step = step || 1;
		let self = this;
		let vo: GuideVO = data[step];
		this.bindData(vo);
	}

	private bindData(vo: GuideVO) {
		if (vo) {
			let self = this;
			if (vo.npcPos && vo.npcPos.length > 0) {
				self.npcImg.x = vo.npcPos[0]
				self.npcImg.y = vo.npcPos[1]
			} else {
				self.npcImg.x = 200;
				self.npcImg.y = 100;
			}
			self.dialogGrp.x = self.npcImg.x;
			self.dialogGrp.y = self.npcImg.y - 10 - self.dialogGrp.height;
			let arr = vo.guideRect;
			self.setGuide(arr[0], arr[1], arr[2], arr[3], vo.side);
		}
	}

	/**
	 * 设置引导框
	 */
	public setGuideRect(rect: egret.Rectangle, side) {
		this.setGuide(rect.x, rect.y, rect.width, rect.height, side);
	}

	/**
	 * 设置边框位置
	 * @param x  框x坐标
	 * @param y  框y坐标
	 * @param w  框宽
	 * @param h  框高
	 * @param side 手指方位 左右上下
	 */
	public setGuide(x, y, w, h, side) {
		let self = this;
		if (!this.arrowsGrp.visible) { return; };
		self.touchRect = self.touchRect || new egret.Rectangle();

		self.touchRect.x = x;
		self.touchRect.y = y;
		self.touchRect.width = w;
		self.touchRect.height = h;

		self.guideRect.x = x;
		self.guideRect.y = y;
		self.guideRect.width = w;
		self.guideRect.height = h;
		let handX: number = 0;
		let handY: number = 0;
		let handW: number = self.arrowsGrp.width;
		let handH: number = self.arrowsGrp.height;
		let handR: number = self.arrowsGrp.rotation;
		let maxWidth = this.width;

		switch (side) {
			case Side.Left:
				handX = x - handW - self.panding;
				handY = y + (h - handH) / 2;
				handR = 0;
				maxWidth = this.width;

				break;
			case Side.Right:
				handX = x + w + handW + self.panding;
				handY = y + (h - handH) / 2 + handH;
				handR = 180;
				maxWidth = this.width;

				break;
			case Side.Top:
				handX = x + (w + handH) / 2;
				handY = y - handW - self.panding;
				handR = 90;
				maxWidth = this.touchTip.size;

				break;
			case Side.Bottom:
				handX = x + (w - handH) / 2;
				handY = y + h + handW + self.panding;
				handR = 270;
				maxWidth = this.touchTip.size;

				break;
		}
		self.arrowsGrp.x = handX;
		self.arrowsGrp.y = handY;
		self.arrowsGrp.rotation = handR;
		self.touchTip.rotation = - handR;
		self.touchTip.maxWidth = maxWidth;
		self.createTween(side);
	}

	// 创建箭头动画
	private createTween(side) {
		let self = this;
		let key: string;
		let value = [];
		switch (side) {
			case Side.Left:
				key = "x";
				value[0] = self.arrowsGrp.x + self.panding;
				value[1] = self.arrowsGrp.x;
				break;
			case Side.Right:
				key = "x";
				value[0] = self.arrowsGrp.x - self.panding;
				value[1] = self.arrowsGrp.x;
				break;
			case Side.Top:
				key = "y";
				value[0] = self.arrowsGrp.y - self.panding;
				value[1] = self.arrowsGrp.y;
				break;
			case Side.Bottom:
				key = "y";
				value[0] = self.arrowsGrp.y - self.panding;
				value[1] = self.arrowsGrp.y;
				break;
			default:
				break;
		}
		this.elasticObj(self.arrowsGrp, self.effectTime, key, self.panding);
	}

	public destory() {
		if (this.stage && !this.stage.hasEventListener(egret.TouchEvent.TOUCH_TAP)) {
			this.stage.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onGuideTouch, this);
		}
		if (this.parent) {
			this.parent.removeChild(this);
		}
	}

	/**
	* 弹簧浮动效果 来回移动效果
	* @param obj 对象
	* @param time 半周期时间
	* @param key 轴 “x” 或 “y” 
	* @param space 幅度 
	*/
	private elasticObj(obj: any, time: number, key: string, space: number = 50) {
		if (obj) {
			egret.Tween.removeTweens(obj);
			let data1 = {};
			data1[key] = obj[key] - space;
			let data2 = {};
			data2[key] = obj[key] + space;
			let onComplete1: Function = function () {
				if (obj != null) {
					let onComplete2: Function = function () {
						egret.Tween.get(obj).to(data1, time).call(onComplete1, this);
					};
					egret.Tween.get(obj).to(data2, time).call(onComplete2, this);
				}
			};
			onComplete1();
		}
	}
}



```

## 配置设计
配置的三个基本要素：1.步骤 step ，2.类型type，点击类，对话类 3.UI
因此，引导可以这么配置 

step|type|UI|
---|:---|---|
1|0|[0,1,2]|
2|0|[1,1,4,4]|

UI配置说明： UI的设计，通常是一个树的数据结构。理想状态下，我们能更数结构访问到我们需要的ui，step 1的ui[0,1,2],层级为0=>1=>2 ，可能是0主界面，1为0界面上的某个面板，2为我们要引导点击的Button  
这样的一个配置，必须要有一个树结构的UI设计和管理，树结构的UI的配置表。 
当然，不是每个项目，都有那么完整的UI设计。如果针对单纯对话的引导，我们可以不指示玩家点击，任意点击触发下一步即可，那么针对指引点击的，我们的目的就是：只在哪个场景哪个界面点击到哪里。

参考：
以下配置是针对本人在某一个游戏开发中设计的，配置的设计根据项目进行，不是很好。项目并没有统一的UI管理或者UI功能配置，也没有树结构的配置或者管理。所以，引导的配置还是根据项目来实行。基本，在该项目中打开界面都是消息派发，因此只需要监听打开界面的消息，去判断所在场景与面板。还有一个配置消息的，在此不列出来了。 
 
字段 |说明|
---|:---|
id |主键	|
desc|描述|	
type|类型|
first|首次步数|
next|下一步|
scene|所在场景|
panel|	所在面板|
opneLevel|开启等级|
closeLevel|自动关闭等级|
dialog|	对话|
npcPos|npc位置|
isGuideUI	|是否显示引导手势|
guideRect|点击区域|
side|	手指方位
sideText|手指提示文本|
